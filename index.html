<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ARC Raiders Quest Tracker</title>
    
    <!-- React Flow CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reactflow@11.10.4/dist/style.css">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
        }

        #root {
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .react-flow {
            background: #1a1a1a;
        }

        /* Custom Quest Node Styles */
        .quest-node {
            padding: 16px;
            border-radius: 8px;
            background: #2c2c2c;
            border: 2px solid #444;
            min-width: 280px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        }

        /* Map Node Styles */
        .map-node {
            border-radius: 12px;
            background: linear-gradient(135deg, #263238, #37474f);
            border: 2px solid transparent;
            min-width: 280px;
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.5);
            transition: all 0.2s ease;
            overflow: hidden;
        }

        .map-node:hover {
            cursor: pointer;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.7);
        }

        .map-node.completed {
            opacity: 0.7;
            background: linear-gradient(135deg, #1b5e20, #2e7d32);
        }

        .map-node-image {
            width: 100%;
            height: 80px;
            object-fit: cover;
            opacity: 0.6;
        }

        .map-node.completed .map-node-image {
            opacity: 0.4;
        }

        .map-node-content {
            padding: 8px 12px;
            text-align: center;
        }

        .map-node-name {
            font-size: 14px;
            font-weight: bold;
            color: #90caf9;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.8);
        }

        .map-node.completed .map-node-name {
            color: #a8d5a8;
        }

        .map-node-status {
            font-size: 11px;
            color: #b0bec5;
            margin-top: 4px;
        }

        .quest-node:hover {
            cursor: pointer;
        }

        .quest-node.available {
            border-color: #ffd700;
            border-width: 3px;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
        }

        .quest-node.completed {
            background: #1b4d2b;
            border-color: #2e7d4e;
            border-width: 3px;
            opacity: 0.85;
        }

        .quest-node-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 12px;
            padding-bottom: 10px;
            border-bottom: 1px solid #444;
        }

        .trader-icon {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 18px;
            color: white;
            flex-shrink: 0;
        }

        .trader-celeste { background: linear-gradient(135deg, #7b1fa2, #9c27b0); }
        .trader-shani { background: linear-gradient(135deg, #f57c00, #ff9800); }
        .trader-lance { background: linear-gradient(135deg, #388e3c, #4caf50); }
        .trader-tianwen { background: linear-gradient(135deg, #c62828, #e53935); }
        .trader-apollo { background: linear-gradient(135deg, #0277bd, #0288d1); }
        .trader-map { background: linear-gradient(135deg, #455a64, #607d8b); }

        .quest-info {
            flex: 1;
        }

        .quest-id {
            font-size: 11px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .quest-name {
            font-size: 16px;
            font-weight: bold;
            color: #e0e0e0;
            margin-top: 4px;
            line-height: 1.3;
        }

        .quest-node.completed .quest-name {
            color: #a8d5a8;
        }

        .quest-node-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 10px;
            gap: 8px;
        }

        .quest-status {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
            color: #888;
        }

        .status-icon {
            font-size: 16px;
        }

        .quest-actions {
            display: flex;
            gap: 6px;
        }

        .quest-action-btn {
            background: #3c3c3c;
            border: 1px solid #555;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 11px;
            color: #e0e0e0;
            cursor: pointer;
            text-decoration: none;
            transition: all 0.2s;
        }

        .quest-action-btn:hover {
            background: #4c4c4c;
            border-color: #777;
        }

        /* React Flow Controls */
        .react-flow__controls {
            background: #2c2c2c;
            border: 1px solid #444;
            border-radius: 8px;
        }

        .react-flow__controls-button {
            background: #2c2c2c;
            border-bottom: 1px solid #444;
            color: #e0e0e0;
        }

        .react-flow__controls-button:hover {
            background: #3c3c3c;
        }

        /* Hide handles */
        .react-flow__handle {
            opacity: 0;
            pointer-events: none;
        }

        /* Edge styles */
        .react-flow__edge-path {
            stroke: #555;
            stroke-width: 2;
        }

        .react-flow__edge.completed .react-flow__edge-path {
            stroke: #2e7d4e;
            stroke-width: 2.5;
        }

        .react-flow__edge.available .react-flow__edge-path {
            stroke: #888;
            stroke-width: 2.5;
        }

        /* Arrow markers */
        .react-flow__arrowhead path,
        .react-flow__arrowhead polyline,
        .react-flow__arrowhead polygon {
            fill: #555 !important;
            stroke: #555 !important;
        }

        .react-flow__edge.completed .react-flow__arrowhead path,
        .react-flow__edge.completed .react-flow__arrowhead polyline,
        .react-flow__edge.completed .react-flow__arrowhead polygon {
            fill: #2e7d4e !important;
            stroke: #2e7d4e !important;
        }

        .react-flow__edge.available .react-flow__arrowhead path,
        .react-flow__edge.available .react-flow__arrowhead polyline,
        .react-flow__edge.available .react-flow__arrowhead polygon {
            fill: #888 !important;
            stroke: #888 !important;
        }

        /* Force arrow marker visibility */
        marker polyline {
            fill: inherit !important;
            stroke: inherit !important;
        }

        /* Header */
        .app-header {
            flex-shrink: 0;
            background: #2c2c2c;
            padding: 16px 24px;
            border-bottom: 2px solid #444;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            text-align: center;
        }

        .app-header h1 {
            font-size: 20px;
            color: #4fc3f7;
            text-shadow: 0 0 10px rgba(79, 195, 247, 0.5);
            margin: 0;
        }

        /* Graph container */
        .graph-container {
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        /* Stats */
        .stats {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            background: rgba(44, 44, 44, 0.95);
            padding: 12px 24px;
            border-radius: 8px;
            border: 1px solid #444;
            display: flex;
            gap: 30px;
            backdrop-filter: blur(10px);
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #4fc3f7;
        }

        .stat-label {
            font-size: 11px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <!-- React, React DOM, and React Flow via CDN -->
    <script crossorigin src="https://unpkg.com/react@18.2.0/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone@7.23.5/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/reactflow@11.10.4/dist/umd/index.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dagre@0.8.5/dist/dagre.min.js"></script>

    <script type="text/babel">
        const { useState, useCallback, useMemo } = React;
        const { ReactFlow, Controls, Background, useNodesState, useEdgesState, MarkerType, Handle, Position } = window.ReactFlow;

        // Map prerequisite nodes (not from arctracker data)
        const MAP_NODES = [
            {id: 'map_dam_battleground', name: 'üó∫Ô∏è Dam Battleground', trader: 'Map', previousQuestIds: [], nextQuestIds: ['ss1']},
            {id: 'map_blue_gate', name: 'üó∫Ô∏è Blue Gate', trader: 'Map', previousQuestIds: [], nextQuestIds: ['ss11']},
            {id: 'map_stella_montis', name: 'üó∫Ô∏è Stella Montis', trader: 'Map', previousQuestIds: [], nextQuestIds: ['12_in_my_image']}
        ];

        // Quest data from the main tracker
        const QUEST_DATA = [{"id":"ss5","name":"A Bad Feeling","trader":"Celeste","previousQuestIds":["ss4"],"nextQuestIds":["ss5a","ss7","ss8"]},{"id":"ss10x","name":"A Balanced Harvest","trader":"Celeste","previousQuestIds":["ss10s"],"nextQuestIds":["ss10x2"]},{"id":"ss10","name":"A Better Use","trader":"Tian Wen","previousQuestIds":["ss7"],"nextQuestIds":["ss10a"]},{"id":"ss11","name":"A First Foothold","trader":"Shani","previousQuestIds":["map_blue_gate"],"nextQuestIds":["ss11a"]},{"id":"ss10k","name":"A Lay of the Land","trader":"Shani","previousQuestIds":["ss10g"],"nextQuestIds":["ss10s"]},{"id":"ss10x19","name":"A New Type of Plant","trader":"Lance","previousQuestIds":["ss10x18"],"nextQuestIds":["ss10x20"]},{"id":"ss10g","name":"A Reveal in Ruins","trader":"Lance","previousQuestIds":["ss10f"],"nextQuestIds":["ss10k"]},{"id":"ss10r","name":"A Symbol of Unification","trader":"Celeste","previousQuestIds":["ss10q"],"nextQuestIds":["ss10t","ss10u","ss10v"]},{"id":"a_toxic_trail","name":"A Toxic Trail","trader":"Shani","previousQuestIds":["ss10x20"],"nextQuestIds":["the_stench_of_corruption"]},{"id":"ss10x8","name":"A Warm Place to Rest","trader":"Apollo","previousQuestIds":["ss10x7"],"nextQuestIds":["ss10x9"]},{"id":"ss10y","name":"After Rain Comes","trader":"Celeste","previousQuestIds":["ss10s"],"nextQuestIds":["ss10x4"]},{"id":"ss10x20","name":"Armored Transports","trader":"Shani","previousQuestIds":["ss10x19","ss11bx"],"nextQuestIds":["a_toxic_trail","paving_the_way"]},{"id":"ss10w","name":"Back on Top","trader":"Tian Wen","previousQuestIds":["ss10t"],"nextQuestIds":["ss10z"]},{"id":"ss10x12","name":"Bees!","trader":"Celeste","previousQuestIds":["ss10x11"],"nextQuestIds":["ss10x13"]},{"id":"ss10h","name":"Broken Monument","trader":"Tian Wen","previousQuestIds":["ss10e"],"nextQuestIds":["ss10i","ss10j"]},{"id":"ss10x18","name":"Building a Library","trader":"Apollo","previousQuestIds":["ss10x16"],"nextQuestIds":["ss10x19"]},{"id":"ss10t","name":"Celeste's Journals","trader":"Celeste","previousQuestIds":["ss10r"],"nextQuestIds":["ss10w"]},{"id":"ss2","name":"Clearer Skies","trader":"Shani","previousQuestIds":["ss1"],"nextQuestIds":["ss4"]},{"id":"12_cold_storage","name":"Cold Storage","trader":"Celeste","previousQuestIds":["12_in_my_image"],"nextQuestIds":["12_snap_and_salvage"]},{"id":"ss11b2","name":"Communication Hideout","trader":"Shani","previousQuestIds":["ss11b"],"nextQuestIds":["ss10x5"]},{"id":"deciphering_the_data","name":"Deciphering the Data","trader":"Shani","previousQuestIds":["a_toxic_trail","paving_the_way"],"nextQuestIds":["groundbreaking"]},{"id":"ss10x16","name":"Digging Up Dirt","trader":"Celeste","previousQuestIds":["ss10x15"],"nextQuestIds":["ss10x17","ss10x18"]},{"id":"ss10c","name":"Doctor's Orders","trader":"Celeste","previousQuestIds":["ss10a"],"nextQuestIds":["ss10f"]},{"id":"ss10b","name":"Dormant Barons","trader":"Shani","previousQuestIds":["ss10a"],"nextQuestIds":["ss10d","ss10e"]},{"id":"ss6","name":"Down To Earth","trader":"Shani","previousQuestIds":["ss5a"],"nextQuestIds":["ss9"]},{"id":"ss10p","name":"Echoes of Victory Ridge","trader":"Celeste","previousQuestIds":["ss10o"],"nextQuestIds":["ss10q"]},{"id":"ss10x13","name":"Espresso","trader":"Apollo","previousQuestIds":["ss10x12"],"nextQuestIds":["ss10x14"]},{"id":"ss10s","name":"Eyes in the Sky","trader":"Shani","previousQuestIds":["ss10k"],"nextQuestIds":["ss10w","ss10x","ss10y"]},{"id":"ss10m","name":"Eyes on the Prize","trader":"Tian Wen","previousQuestIds":["ss10l"],"nextQuestIds":["ss10n"]},{"id":"ss10x11","name":"Flickering Threat","trader":"Celeste","previousQuestIds":["ss10x10"],"nextQuestIds":["ss10x12"]},{"id":"ss10a","name":"Greasing Her Palms","trader":"Celeste","previousQuestIds":["ss10"],"nextQuestIds":["ss10b","ss10c"]},{"id":"groundbreaking","name":"Groundbreaking","trader":"Apollo","previousQuestIds":["deciphering_the_data"],"nextQuestIds":[]},{"id":"ss5a","name":"Hatch Repairs","trader":"Shani","previousQuestIds":["ss5"],"nextQuestIds":["ss6"]},{"id":"12_in_my_image","name":"In My Image","trader":"Lance","previousQuestIds":["map_stella_montis"],"nextQuestIds":["12_cold_storage"]},{"id":"ss10n","name":"Industrial Espionage","trader":"Tian Wen","previousQuestIds":["ss10m"],"nextQuestIds":["ss10q"]},{"id":"ss10x5","name":"Into the Fray","trader":"Shani","previousQuestIds":["ss10x4","ss11b2"],"nextQuestIds":[]},{"id":"ss10o","name":"Keeping the Memory","trader":"Celeste","previousQuestIds":["ss10j"],"nextQuestIds":["ss10p"]},{"id":"ss10x14","name":"Life of a Pharmacist","trader":"Lance","previousQuestIds":["ss10x13"],"nextQuestIds":["ss10x15"]},{"id":"ss11b","name":"Lost in Transmission","trader":"Shani","previousQuestIds":["ss10z"],"nextQuestIds":["ss11b2"]},{"id":"ss10i","name":"Marked for Death","trader":"Tian Wen","previousQuestIds":["ss10h"],"nextQuestIds":["ss10l"]},{"id":"ss10l","name":"Market Correction","trader":"Tian Wen","previousQuestIds":["ss10i"],"nextQuestIds":["ss10m"]},{"id":"ss10f","name":"Medical Merchandise","trader":"Lance","previousQuestIds":["ss10c"],"nextQuestIds":["ss10g"]},{"id":"ss10d","name":"Mixed Signals","trader":"Tian Wen","previousQuestIds":["ss10b"],"nextQuestIds":[]},{"id":"ss4","name":"Off The Radar","trader":"Shani","previousQuestIds":["ss2","ss3"],"nextQuestIds":["ss5"]},{"id":"ss10z","name":"Our Presence Up There","trader":"Shani","previousQuestIds":["ss10w"],"nextQuestIds":["ss11b"]},{"id":"ss10v","name":"Out of the Shadows","trader":"Shani","previousQuestIds":["ss10r"],"nextQuestIds":[]},{"id":"paving_the_way","name":"Paving the Way","trader":"Apollo","previousQuestIds":["ss10x20"],"nextQuestIds":["deciphering_the_data"]},{"id":"ss1","name":"Picking Up The Pieces","trader":"Shani","previousQuestIds":["map_dam_battleground"],"nextQuestIds":["ss2","ss3"]},{"id":"ss10x10","name":"Power Out","trader":"Celeste","previousQuestIds":["ss10x9"],"nextQuestIds":["ss10x11"]},{"id":"ss10x9","name":"Prescriptions of the Past","trader":"Lance","previousQuestIds":["ss10x8"],"nextQuestIds":["ss10x10"]},{"id":"ss11a","name":"Reduced to Rubble","trader":"Shani","previousQuestIds":["ss11"],"nextQuestIds":["ss11bx"]},{"id":"ss8","name":"Safe Passage","trader":"Apollo","previousQuestIds":["ss5"],"nextQuestIds":["ss8a"]},{"id":"12_snap_and_salvage","name":"Snap and Salvage","trader":"Tian Wen","previousQuestIds":["12_cold_storage"],"nextQuestIds":[]},{"id":"ss10x6","name":"Source of the Contamination","trader":"Celeste","previousQuestIds":["ss10x4"],"nextQuestIds":["ss10x7"]},{"id":"ss8b","name":"Sparks Fly","trader":"Apollo","previousQuestIds":["ss8a"],"nextQuestIds":[]},{"id":"ss10j","name":"Straight Record","trader":"Celeste","previousQuestIds":["ss10h"],"nextQuestIds":["ss10o"]},{"id":"ss10x7","name":"Switching the Supply","trader":"Celeste","previousQuestIds":["ss10x6"],"nextQuestIds":["ss10x8"]},{"id":"the_clean_dream","name":"The Clean Dream","trader":"Apollo","previousQuestIds":["ss11bx"],"nextQuestIds":[]},{"id":"ss10u","name":"The Major's Footlocker","trader":"Tian Wen","previousQuestIds":["ss10r"],"nextQuestIds":[]},{"id":"ss7","name":"The Right Tool","trader":"Tian Wen","previousQuestIds":["ss5"],"nextQuestIds":["ss10"]},{"id":"ss10x3","name":"The Root of the Matter","trader":"Celeste","previousQuestIds":["ss10x2"],"nextQuestIds":["ss10x4"]},{"id":"the_stench_of_corruption","name":"The Stench of Corruption","trader":"Shani","previousQuestIds":["a_toxic_trail"],"nextQuestIds":[]},{"id":"ss9","name":"The Trifecta","trader":"Shani","previousQuestIds":["ss6"],"nextQuestIds":[]},{"id":"ss3","name":"Trash Into Treasure","trader":"Shani","previousQuestIds":["ss1"],"nextQuestIds":["ss4"]},{"id":"ss10x15","name":"Tribute to Toledo","trader":"Celeste","previousQuestIds":["ss10x14"],"nextQuestIds":["ss10x16"]},{"id":"ss10x17","name":"Turnabout","trader":"Celeste","previousQuestIds":["ss10x16"],"nextQuestIds":[]},{"id":"ss10q","name":"Unexpected Initiative","trader":"Tian Wen","previousQuestIds":["ss10p","ss10n"],"nextQuestIds":["ss10r"]},{"id":"ss10x2","name":"Untended Garden","trader":"Celeste","previousQuestIds":["ss10x"],"nextQuestIds":["ss10x3"]},{"id":"ss10x4","name":"Water Troubles","trader":"Celeste","previousQuestIds":["ss10x3","ss10y"],"nextQuestIds":["ss10x5","ss10x6"]},{"id":"ss8a","name":"What Goes Around","trader":"Apollo","previousQuestIds":["ss8"],"nextQuestIds":["ss8b"]},{"id":"ss10e","name":"What We Left Behind","trader":"Tian Wen","previousQuestIds":["ss10b"],"nextQuestIds":["ss10h"]},{"id":"ss11bx","name":"With a Trace","trader":"Shani","previousQuestIds":["ss11a"],"nextQuestIds":["the_clean_dream"]}];

        // Combine maps and quests
        const QUESTS = [...MAP_NODES, ...QUEST_DATA];

        // Map image mapping
        const MAP_IMAGES = {
            'map_dam_battleground': 'images/Dam_Battlegrounds.png.webp',
            'map_blue_gate': 'images/Blue_Gate.png.webp',
            'map_stella_montis': 'images/Stella_Montis.png.webp'
        };

        // Custom Map Node Component
        function MapNode({ data }) {
            const { quest, isCompleted, onToggle } = data;
            const mapImage = MAP_IMAGES[quest.id];
            const displayName = quest.name.replace('üó∫Ô∏è ', ''); // Remove emoji
            
            const handleClick = (e) => {
                e.stopPropagation();
                onToggle(quest.id);
            };

            return (
                <div className={`map-node ${isCompleted ? 'completed' : ''}`} onClick={handleClick}>
                    <Handle type="target" position={Position.Top} />
                    {mapImage && <img src={mapImage} alt={displayName} className="map-node-image" />}
                    <div className="map-node-content">
                        <div className="map-node-name">{displayName}</div>
                        <div className="map-node-status">
                            {isCompleted ? '‚úì Unlocked' : 'üîí Locked'}
                        </div>
                    </div>
                    <Handle type="source" position={Position.Bottom} />
                </div>
            );
        }

        // Custom Quest Node Component
        function QuestNode({ data }) {
            const { quest, isCompleted, isAvailable, onToggle } = data;
            
            const traderClass = `trader-${quest.trader.toLowerCase().replace(' ', '')}`;
            const nodeClass = `quest-node ${isCompleted ? 'completed' : ''} ${isAvailable ? 'available' : ''}`;

            const getTraderInitial = (trader) => {
                return trader.split(' ').map(w => w[0]).join('');
            };

            const handleClick = (e) => {
                e.stopPropagation();
                onToggle(quest.id);
            };

            return (
                <div className={nodeClass} onClick={handleClick}>
                    <Handle type="target" position={Position.Top} />
                    <div className="quest-node-header">
                        <div className={`trader-icon ${traderClass}`}>
                            {getTraderInitial(quest.trader)}
                        </div>
                        <div className="quest-info">
                            <div className="quest-id">{quest.id}</div>
                            <div className="quest-name">{quest.name}</div>
                        </div>
                    </div>

                    <div className="quest-node-footer">
                        <div className="quest-status">
                            <span className="status-icon">
                                {isCompleted ? '‚úì' : isAvailable ? '‚≠ê' : 'üîí'}
                            </span>
                            <span>
                                {isCompleted ? 'Completed' : isAvailable ? 'Available' : 'Locked'}
                            </span>
                        </div>
                        <div className="quest-actions">
                            <a 
                                href={`https://arcraiders.wiki/wiki/${quest.name.replace(/ /g, '_')}`}
                                target="_blank"
                                className="quest-action-btn"
                                onClick={(e) => e.stopPropagation()}
                            >
                                üìñ Wiki
                            </a>
                        </div>
                    </div>
                    <Handle type="source" position={Position.Bottom} />
                </div>
            );
        }

        // Main App Component
        function QuestTracker() {
            // Load completed quests from localStorage
            const loadCompletedQuests = () => {
                try {
                    const saved = localStorage.getItem('arcraiders-quest-progress-reactflow');
                    if (saved) {
                        return new Set(JSON.parse(saved));
                    }
                } catch (e) {
                    console.error('Failed to load quest progress:', e);
                }
                return new Set();
            };

            const [completedQuests, setCompletedQuests] = useState(loadCompletedQuests);
            
            // Save to localStorage whenever completedQuests changes
            React.useEffect(() => {
                try {
                    localStorage.setItem('arcraiders-quest-progress-reactflow', JSON.stringify(Array.from(completedQuests)));
                } catch (e) {
                    console.error('Failed to save quest progress:', e);
                }
            }, [completedQuests]);
            
            // Node types registration
            const nodeTypes = useMemo(() => ({ 
                questNode: QuestNode,
                mapNode: MapNode 
            }), []);

            // Check if quest is available
            const isQuestAvailable = useCallback((quest) => {
                if (completedQuests.has(quest.id)) return false;
                if (quest.previousQuestIds.length === 0) return true;
                return quest.previousQuestIds.every(id => completedQuests.has(id));
            }, [completedQuests]);

            // Get all quests that depend on this quest (recursively)
            const getAllDependents = useCallback((questId, completed) => {
                const dependents = new Set();
                const toCheck = [questId];
                
                while (toCheck.length > 0) {
                    const current = toCheck.pop();
                    const quest = QUESTS.find(q => q.id === current);
                    if (quest) {
                        quest.nextQuestIds.forEach(nextId => {
                            if (completed.has(nextId) && !dependents.has(nextId)) {
                                dependents.add(nextId);
                                toCheck.push(nextId);
                            }
                        });
                    }
                }
                return dependents;
            }, []);

            // Get all prerequisites recursively
            const getAllPrerequisites = useCallback((questId) => {
                const prerequisites = new Set();
                const toCheck = [questId];
                
                while (toCheck.length > 0) {
                    const current = toCheck.pop();
                    const quest = QUESTS.find(q => q.id === current);
                    if (quest) {
                        quest.previousQuestIds.forEach(prevId => {
                            if (!prerequisites.has(prevId)) {
                                prerequisites.add(prevId);
                                toCheck.push(prevId);
                            }
                        });
                    }
                }
                return prerequisites;
            }, []);

            // Toggle quest completion
            const toggleQuest = useCallback((questId) => {
                setCompletedQuests(prev => {
                    const quest = QUESTS.find(q => q.id === questId);
                    if (!quest) return prev;

                    if (prev.has(questId)) {
                        // Uncompleting a quest - check for completed dependents
                        const dependents = getAllDependents(questId, prev);
                        
                        if (dependents.size > 0) {
                            const dependentNames = Array.from(dependents)
                                .map(id => QUESTS.find(q => q.id === id)?.name)
                                .filter(Boolean);
                            
                            const confirmed = window.confirm(
                                `Marking "${quest.name}" as incomplete will also mark ${dependents.size} dependent quest(s) as incomplete:\n\n` +
                                dependentNames.slice(0, 5).join('\n') +
                                (dependentNames.length > 5 ? `\n...and ${dependentNames.length - 5} more` : '') +
                                `\n\nDo you want to continue?`
                            );
                            
                            if (!confirmed) return prev;
                            
                            // Remove quest and all dependents
                            const newSet = new Set(prev);
                            newSet.delete(questId);
                            dependents.forEach(id => newSet.delete(id));
                            return newSet;
                        } else {
                            // No dependents, just uncomplete
                            const newSet = new Set(prev);
                            newSet.delete(questId);
                            return newSet;
                        }
                    } else {
                        // Completing a quest - check for incomplete prerequisites
                        const incompletePrereqs = quest.previousQuestIds.filter(id => !prev.has(id));
                        
                        if (incompletePrereqs.length > 0) {
                            const allPrereqs = getAllPrerequisites(questId);
                            const incompleteAll = Array.from(allPrereqs).filter(id => !prev.has(id));
                            const prereqNames = incompleteAll
                                .map(id => QUESTS.find(q => q.id === id)?.name)
                                .filter(Boolean);
                            
                            const confirmed = window.confirm(
                                `"${quest.name}" has ${incompleteAll.length} incomplete prerequisite(s):\n\n` +
                                prereqNames.slice(0, 5).join('\n') +
                                (prereqNames.length > 5 ? `\n...and ${prereqNames.length - 5} more` : '') +
                                `\n\nDo you want to auto-complete all prerequisites?`
                            );
                            
                            if (!confirmed) return prev;
                            
                            // Add quest and all prerequisites
                            const newSet = new Set(prev);
                            incompleteAll.forEach(id => newSet.add(id));
                            newSet.add(questId);
                            return newSet;
                        } else {
                            // All prerequisites complete, just complete this quest
                            const newSet = new Set(prev);
                            newSet.add(questId);
                            return newSet;
                        }
                    }
                });
            }, [getAllDependents, getAllPrerequisites]);

            // Create nodes using Dagre layout
            const { nodes, edges } = useMemo(() => {
                const g = new dagre.graphlib.Graph();
                g.setGraph({ rankdir: 'TB', nodesep: 50, ranksep: 70 });
                g.setDefaultEdgeLabel(() => ({}));

                // Add nodes to dagre with appropriate dimensions
                QUESTS.forEach(quest => {
                    const isMap = quest.trader === 'Map';
                    g.setNode(quest.id, { 
                        width: 300,  // Same width for both
                        height: isMap ? 110 : 140 
                    });
                });

                // Add edges to dagre
                QUESTS.forEach(quest => {
                    quest.previousQuestIds.forEach(prevId => {
                        g.setEdge(prevId, quest.id);
                    });
                });

                dagre.layout(g);

                // Create React Flow nodes
                const flowNodes = QUESTS.map(quest => {
                    const nodeWithPosition = g.node(quest.id);
                    const isMap = quest.trader === 'Map';
                    const nodeType = isMap ? 'mapNode' : 'questNode';
                    const width = 300;  // Same width for both types
                    const height = isMap ? 110 : 140;
                    
                    return {
                        id: quest.id,
                        type: nodeType,
                        position: { 
                            x: nodeWithPosition.x - (width / 2), 
                            y: nodeWithPosition.y - (height / 2) 
                        },
                        data: {
                            quest,
                            isCompleted: completedQuests.has(quest.id),
                            isAvailable: isQuestAvailable(quest),
                            onToggle: toggleQuest
                        },
                        draggable: false
                    };
                });

                // Create React Flow edges
                const flowEdges = [];
                QUESTS.forEach(quest => {
                    quest.previousQuestIds.forEach(prevId => {
                        const sourceCompleted = completedQuests.has(prevId);
                        const targetCompleted = completedQuests.has(quest.id);
                        const targetAvailable = isQuestAvailable(quest);
                        
                        let className = '';
                        if (sourceCompleted && targetCompleted) {
                            className = 'completed';
                        } else if (sourceCompleted && targetAvailable) {
                            className = 'available';
                        }

                        const edge = {
                            id: `${prevId}-${quest.id}`,
                            source: prevId,
                            target: quest.id,
                            type: 'default',
                            className,
                            animated: targetAvailable && !targetCompleted,
                            markerEnd: {
                                type: MarkerType.ArrowClosed,
                                color: className === 'completed' ? '#2e7d4e' : className === 'available' ? '#888' : '#555'
                            },
                            style: {
                                stroke: className === 'completed' ? '#2e7d4e' : className === 'available' ? '#888' : '#555',
                                strokeWidth: className === 'completed' ? 2.5 : className === 'available' ? 2.5 : 2
                            }
                        };
                        flowEdges.push(edge);
                    });
                });

                return { nodes: flowNodes, edges: flowEdges };
            }, [completedQuests, isQuestAvailable, toggleQuest]);

            // Initialize state hooks with the computed nodes and edges
            const [flowNodes, setNodes, onNodesChange] = useNodesState(nodes);
            const [flowEdges, setEdges, onEdgesChange] = useEdgesState(edges);

            // Update nodes and edges when completedQuests changes
            React.useEffect(() => {
                setNodes(nodes);
            }, [nodes, setNodes]);
            
            React.useEffect(() => {
                setEdges(edges);
            }, [edges, setEdges]);

            // Filter out map nodes for statistics
            const actualQuests = QUESTS.filter(q => q.trader !== 'Map');
            const availableCount = actualQuests.filter(q => isQuestAvailable(q)).length;
            const completedCount = actualQuests.filter(q => completedQuests.has(q.id)).length;

            // Handle node clicks
            const onNodeClick = useCallback((event, node) => {
                node.data.onToggle(node.id);
            }, []);

            // Calculate bounds for translateExtent
            const bounds = useMemo(() => {
                if (nodes.length === 0) return [[0, 0], [1000, 1000]];
                
                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                nodes.forEach(node => {
                    minX = Math.min(minX, node.position.x);
                    minY = Math.min(minY, node.position.y);
                    maxX = Math.max(maxX, node.position.x + 300); // node width
                    maxY = Math.max(maxY, node.position.y + 140); // node height
                });
                
                // Add padding
                const padding = 100;
                return [
                    [minX - padding, minY - padding],
                    [maxX + padding, maxY + padding]
                ];
            }, [nodes]);

            return (
                <>
                    <div className="app-header">
                        <h1>üéÆ ARC Raiders Quest Tracker</h1>
                    </div>

                    <div className="graph-container">
                        <ReactFlow
                            nodes={flowNodes}
                            edges={flowEdges}
                            onNodesChange={onNodesChange}
                            onEdgesChange={onEdgesChange}
                            onNodeClick={onNodeClick}
                            nodeTypes={nodeTypes}
                            defaultEdgeOptions={{
                                type: 'default',
                                markerEnd: { type: MarkerType.ArrowClosed },
                                style: { strokeWidth: 2 }
                            }}
                            translateExtent={bounds}
                            fitView
                            minZoom={0.3}
                            maxZoom={1.5}
                            defaultViewport={{ x: 0, y: 0, zoom: 0.5 }}
                            nodesDraggable={false}
                            nodesConnectable={false}
                        >
                            <Controls />
                            <Background color="#2c2c2c" gap={16} />
                        </ReactFlow>

                        <div className="stats">
                            <div className="stat-item">
                                <div className="stat-value">{completedCount}</div>
                                <div className="stat-label">Completed</div>
                            </div>
                            <div className="stat-item">
                                <div className="stat-value">{availableCount}</div>
                                <div className="stat-label">Available</div>
                            </div>
                        <div className="stat-item">
                            <div className="stat-value">{actualQuests.length}</div>
                            <div className="stat-label">Total</div>
                        </div>
                        </div>
                    </div>
                </>
            );
        }

        // Render the app
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<QuestTracker />);
    </script>
</body>
</html>
